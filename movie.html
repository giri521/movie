<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Couples Watch Portal</title>
<style>
:root{--accent:#7c3aed;--muted:#666}
*{box-sizing:border-box}
body{margin:0;font-family:Arial,sans-serif;background:#f7f7fb;color:#111}
.wrap{max-width:1100px;margin:18px auto;padding:18px}
.card{background:#fff;border-radius:12px;box-shadow:0 6px 18px rgba(20,20,30,0.06);padding:14px;margin-bottom:12px}
header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
h1{margin:0;font-size:18px}
.cols{display:grid;grid-template-columns:1fr 360px;gap:18px}
button,input{padding:8px;border-radius:8px;border:1px solid #e6e6f0}
button{background:var(--accent);color:#fff;border:0;cursor:pointer}
button.ghost{background:#eef2ff;color:#222}
video#movie{width:100%;max-height:480px;background:#000;border-radius:8px}
video.smallcam{width:160px;height:90px;object-fit:cover;border-radius:8px}
.cam-grid{position:relative}
.cam-overlay{position:absolute;right:8px;top:8px;display:flex;flex-direction:column;gap:8px}
.chat{height:220px;overflow:auto;padding:8px;border-radius:8px;border:1px solid #eee;background:#fbfbff}
.msg{margin-bottom:8px}
@media(max-width:980px){.cols{grid-template-columns:1fr}.cam-overlay{right:4px;top:4px}}
</style>
</head>
<body>
<div class="wrap">
<header>
<h1>Couples Watch Portal</h1>
<div class="small"><span id="userStatus">Please login.</span></div>
</header>

<div class="card" id="authCard">
    <div style="margin-bottom:8px;">
        <input id="usernameInp" type="text" placeholder="Username (Email)" style="width:50%; margin-right:4px;">
        <input id="passwordInp" type="password" placeholder="Password" style="width:calc(50% - 4px);">
    </div>
    <button id="loginBtn">Login</button>
    <button id="registerBtn" class="ghost">Create Account</button>
</div>

<div class="card" id="roomCard" style="display:none">
    <button id="createRoom" class="ghost" disabled>Create Room</button>
    <button id="joinRoom" disabled>Join Room</button>
    <div style="margin-top:8px">Room Code: <b id="roomCodeLabel">â€”</b></div>
</div>

<div class="cols">
<section class="card">
    <label>Select movie/video:</label>
    <input id="fileInp" type="file" accept="video/*" disabled>
    <input id="urlInp" type="text" placeholder="or paste public MP4 URL" style="margin-top:8px;width:100%" disabled>
    <div style="margin-top:8px">
        <button id="hostLoad" disabled>Load Movie</button>
        <button id="playBtn" class="ghost" disabled>Play</button>
        <button id="pauseBtn" class="ghost" disabled>Pause</button>
        <label><input id="camToggle" type="checkbox" disabled> Show Cameras</label>
    </div>
    <div class="cam-grid" style="min-height:140px;margin-top:8px">
        <video id="movie" playsinline controls></video>
        <div class="cam-overlay" id="camOverlay" style="display:none"></div>
    </div>
</section>
<aside class="card">
    <div><b>Participants & Chat</b></div>
    <ul id="parts"></ul>
    <div id="chat" class="chat"></div>
    <div style="display:flex;gap:8px;margin-top:8px">
        <input id="chatInp" placeholder="Message or emoji" disabled>
        <button id="sendChat" disabled>Send</button>
    </div>
</aside>
</div>
</div>
<script src="https://unpkg.com/backendless/dist/backendless.min.js"></script>
<script>
const APP_ID = '175B6549-0AFE-41E3-BBEA-5FDB51825200';
const API_KEY = 'D3301207-E860-4214-BEA5-910123DFEAD7';
Backendless.initApp(APP_ID, API_KEY);

let room = null,
    isHost = false,
    localId = null, // Will be set to Backendless user objectId
    localName = null; // Will be set to the username
let subscription = null,
    pc = null,
    localStream = null,
    movieStream = null,
    remoteStreams = {};
let participants = [];
let peerConnections = {};

// --- DOM Elements ---
const userStatus = document.getElementById('userStatus');
const authCard = document.getElementById('authCard');
const roomCard = document.getElementById('roomCard');
const usernameInp = document.getElementById('usernameInp');
const passwordInp = document.getElementById('passwordInp');
const loginBtn = document.getElementById('loginBtn');
const registerBtn = document.getElementById('registerBtn');
const createBtn = document.getElementById('createRoom');
const joinBtn = document.getElementById('joinRoom');
const roomCodeLabel = document.getElementById('roomCodeLabel');
const partsList = document.getElementById('parts');
const fileInp = document.getElementById('fileInp');
const urlInp = document.getElementById('urlInp');
const hostLoad = document.getElementById('hostLoad');
const movie = document.getElementById('movie');
const playBtn = document.getElementById('playBtn');
const pauseBtn = document.getElementById('pauseBtn');
const camToggle = document.getElementById('camToggle');
const camOverlay = document.getElementById('camOverlay');
const chatBox = document.getElementById('chat');
const chatInp = document.getElementById('chatInp');
const sendChat = document.getElementById('sendChat');


// --- UI Management ---

function updateUI(loggedIn) {
    if (loggedIn) {
        userStatus.textContent = `Logged in as: ${localName}`;
        authCard.style.display = 'none';
        roomCard.style.display = 'block';
        
        // Enable basic room controls and chat
        createBtn.disabled = false;
        joinBtn.disabled = false;
        chatInp.disabled = false;
        sendChat.disabled = false;
        camToggle.disabled = false;
        
        // Movie controls are enabled based on host status, but inputs are still global
        fileInp.disabled = !isHost;
        urlInp.disabled = !isHost;
        hostLoad.disabled = !isHost;
        playBtn.disabled = !isHost;
        pauseBtn.disabled = !isHost;
        
    } else {
        userStatus.textContent = 'Please login.';
        authCard.style.display = 'block';
        roomCard.style.display = 'none';
        
        // Disable everything
        createBtn.disabled = true;
        joinBtn.disabled = true;
        chatInp.disabled = true;
        sendChat.disabled = true;
        camToggle.disabled = true;
        fileInp.disabled = true;
        urlInp.disabled = true;
        hostLoad.disabled = true;
        playBtn.disabled = true;
        pauseBtn.disabled = true;
    }
}


// --- Authentication Functions ---

async function loginUser() {
    const username = usernameInp.value.trim();
    const password = passwordInp.value.trim();
    if (!username || !password) return alert('Enter username and password.');

    try {
        const user = await Backendless.UserService.login(username, password, true);
        localId = user.objectId;
        localName = user.name || user.email.split('@')[0] || username; // Use 'name' field if available, otherwise email prefix
        appendChat(`Logged in successfully as ${localName}.`, 'system');
        updateUI(true);
    } catch (e) {
        alert('Login failed: ' + e.message);
    }
}

async function registerUser() {
    const username = usernameInp.value.trim();
    const password = passwordInp.value.trim();
    if (!username || !password) return alert('Enter username and password.');

    try {
        // Backendless uses the email field for username/login by default
        const user = await Backendless.UserService.register({
            email: username,
            password: password,
            name: username.split('@')[0] // Store a simple name
        });
        alert(`Account created for ${username}! Please log in.`);
        usernameInp.value = username; // Pre-fill login
        // Do not auto-login; prompt user to log in after registration
    } catch (e) {
        alert('Registration failed: ' + e.message);
    }
}

// --- Utility Functions (Same as previous, simplified/renamed) ---

function appendChat(text, from = 'system') {
    const div = document.createElement('div');
    div.className = 'msg';
    div.innerHTML = `<b>${from}:</b> ${text}`;
    chatBox.appendChild(div);
    chatBox.scrollTop = chatBox.scrollHeight;
}

function updateParticipants(list) {
    participants = list || [];
    partsList.innerHTML = '';
    participants.forEach(p => {
        const li = document.createElement('li');
        li.textContent = p === localName ? p + ' (You)' : p;
        partsList.appendChild(li);
    });
}

function channelName(code) {
    return 'room_' + code;
}

async function subscribe(code) {
    if (subscription) await Backendless.Messaging.unsubscribe(subscription);
    subscription = await Backendless.Messaging.subscribe(channelName(code), m => {
        const msg = Array.isArray(m) ? m[0] : m;
        if (msg.sender === localId) return;
        handleMessage(msg);
    });
}

async function publish(code, payload) {
    if (!localId) return console.error('Not logged in to publish.');
    payload.sender = localId;
    payload.time = Date.now();
    try {
        await Backendless.Messaging.publish(channelName(code), payload);
    } catch (e) {
        console.error('Publish error:', e);
    }
}

async function ensureRoomsTable() {
    try {
        await Backendless.Data.describe('Rooms');
    } catch (e) {
        await Backendless.Data.of('Rooms').save({
            code: 'INIT',
            roomName: 'Init',
            hostId: 'SYS',
            createdAt: new Date()
        });
        await Backendless.Data.of('Rooms').remove('INIT');
    }
}
ensureRoomsTable();

// --- WebRTC (Simplified Signaling/Streaming - Same logic as before, using IDs) ---

const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];

function getPeerConnection(remoteSenderId) {
    if (peerConnections[remoteSenderId]) return peerConnections[remoteSenderId];
    // ... (WebRTC PC setup remains the same)
    const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
    peerConnections[remoteSenderId] = pc;

    pc.onicecandidate = ({ candidate }) => {
        if (candidate) {
            publish(room.code, { type: 'webrtc_signal', signal: { type: 'candidate', candidate }, to: remoteSenderId });
        }
    };

    pc.ontrack = (event) => {
        const stream = event.streams[0];
        if (!remoteStreams[remoteSenderId]) {
            appendChat('New video stream received.', 'system');
            const video = document.createElement('video');
            video.autoplay = true;
            video.playsinline = true;
            video.muted = false;
            video.className = 'smallcam';
            video.srcObject = stream;
            camOverlay.appendChild(video);
            remoteStreams[remoteSenderId] = { stream, video };
        }
    };
    return pc;
}

async function startCameraStream() {
    if (!localId) return;
    try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        appendChat('Camera/mic stream started.', 'system');
        const localVideo = document.createElement('video');
        localVideo.autoplay = true;
        localVideo.playsinline = true;
        localVideo.muted = true;
        localVideo.className = 'smallcam';
        localVideo.id = 'localCam';
        localVideo.srcObject = localStream;
        camOverlay.prepend(localVideo);
        
        // Find the partner's ID (simple assumption: one host, one guest)
        const remoteId = isHost ? room.guestId : room.hostId;
        if (remoteId) initiateWebRTCCall(remoteId);

    } catch (e) {
        appendChat('Failed to start camera/mic: ' + e.message, 'system');
        localStream = null;
        camToggle.checked = false;
    }
}

function stopCameraStream() {
    if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
        camOverlay.innerHTML = '';
        remoteStreams = {};
        peerConnections = {};
        appendChat('Camera/mic stream stopped.', 'system');
    }
}

async function initiateWebRTCCall(remoteSenderId) {
    if (!localStream || !remoteSenderId) return;

    const pc = getPeerConnection(remoteSenderId);

    localStream.getTracks().forEach(track => {
        if (!pc.getSenders().find(sender => sender.track === track)) {
            pc.addTrack(track, localStream);
        }
    });

    const offer = await pc.createOffer();
    await pc.setLocalDescription(offer);
    publish(room.code, { type: 'webrtc_signal', signal: pc.localDescription, to: remoteSenderId });
}

// --- Message Handler ---

async function handleMessage(msg) {
    if (msg.type === 'chat') {
        appendChat(msg.text, msg.from);

    } else if (msg.type === 'presence' || msg.type === 'presence_join') {
        if (msg.type === 'presence_join') {
            appendChat(`${msg.name} joined.`, 'system');
            
            if (isHost) {
                // Host updates the room record with the guest ID
                room.guestId = msg.sender;
                await Backendless.Data.of('Rooms').save(room);
                
                // Host publishes the updated participant list
                publish(room.code, { type: 'presence', participants: [...participants.filter(p => p !== msg.name), msg.name] });
                
                // If camera is on, host initiates call
                if (camToggle.checked && localStream) initiateWebRTCCall(room.guestId);
            }
        }
        if (msg.participants) updateParticipants(msg.participants);

    } else if (msg.type === 'movie_loaded') {
        if (!isHost) {
            if (msg.kind === 'url') {
                // *** FIX: Guest loads the public URL to make the video visible ***
                movie.src = msg.url;
                await movie.load();
                appendChat('Host loaded URL. Video is now visible.', 'system');
            } else if (msg.kind === 'capture') {
                appendChat('Host loaded local file (content cannot be synced).', 'system');
            }
        }

    } else if (msg.type === 'movie_play') {
        if (!isHost) { movie.currentTime = msg.time; movie.play(); }

    } else if (msg.type === 'movie_pause') {
        if (!isHost) { movie.currentTime = msg.time; movie.pause(); }

    } else if (msg.type === 'webrtc_signal') {
        if (msg.to && msg.to !== localId) return;

        const signal = msg.signal;
        const remoteSenderId = msg.sender;
        const pc = getPeerConnection(remoteSenderId);

        if (signal.type === 'offer') {
            if (!localStream) { camToggle.checked = true; await startCameraStream(); }

            await pc.setRemoteDescription(new RTCSessionDescription(signal));
            localStream.getTracks().forEach(track => {
                if (!pc.getSenders().find(sender => sender.track === track)) { pc.addTrack(track, localStream); }
            });

            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            publish(room.code, { type: 'webrtc_signal', signal: pc.localDescription, to: remoteSenderId });

        } else if (signal.type === 'answer') {
            await pc.setRemoteDescription(new RTCSessionDescription(signal));

        } else if (signal.type === 'candidate') {
            try {
                await pc.addIceCandidate(signal.candidate);
            } catch (e) { console.error('Error adding ICE candidate:', e); }
        }
    }
}

// --- Event Listeners ---

loginBtn.addEventListener('click', loginUser);
registerBtn.addEventListener('click', registerUser);

createBtn.addEventListener('click', async () => {
    if (!localId) return alert('Please log in first.');

    const roomName = prompt('Enter room name') || 'Room';
    const code = Math.random().toString(36).slice(2, 7).toUpperCase();
    const Rooms = Backendless.Data.of('Rooms');
    try {
        const rec = { code, roomName, hostId: localId, guestId: null, createdAt: new Date() };
        room = await Rooms.save(rec);
        isHost = true;
        roomCodeLabel.textContent = room.code;
        await subscribe(room.code);
        appendChat(`Room created. You are the host. Share code: ${room.code}`, 'system');
        publish(room.code, { type: 'presence', participants: [localName] });
        updateParticipants([localName]);
        updateUI(true); // Update UI to reflect host controls
    } catch (e) {
        alert('Failed to create room: ' + e.message);
    }
});

joinBtn.addEventListener('click', async () => {
    if (!localId) return alert('Please log in first.');

    const code = prompt('Enter room code').trim().toUpperCase();
    if (!code) return;
    const Rooms = Backendless.Data.of('Rooms');
    try {
        const found = await Rooms.find({ where: `code='${code}'` });
        if (!found || !found.length) return alert('Room not found');
        room = found[0];
        isHost = false;
        roomCodeLabel.textContent = room.code;
        await subscribe(room.code);
        appendChat(`Joined room: ${room.code}`, 'system');
        publish(room.code, { type: 'presence_join', name: localName });
        updateParticipants([localName]);
        updateUI(true); // Update UI to reflect guest controls
    } catch (e) {
        alert('Failed to join room: ' + e.message);
    }
});

sendChat.addEventListener('click', () => {
    const t = chatInp.value.trim();
    if (!t || !room || !localId) return;

    // Send and append locally
    publish(room.code, { type: 'chat', text: t, from: localName });
    appendChat(t, 'you');
    chatInp.value = '';
});

// Video sync listeners (only host publishing matters)
movie.addEventListener('play', () => { if (room && isHost) publish(room.code, { type: 'movie_play', time: movie.currentTime }); });
movie.addEventListener('pause', () => { if (room && isHost) publish(room.code, { type: 'movie_pause', time: movie.currentTime }); });

hostLoad.addEventListener('click', async () => {
    if (!room || !isHost) return alert('You must be the host and in a room to load a movie.');

    const file = fileInp.files[0];
    const url = urlInp.value.trim();

    if (file) {
        const blob = URL.createObjectURL(file);
        movie.src = blob;
        await movie.load();
        appendChat('Loaded local file', 'system');
        publish(room.code, { type: 'movie_loaded', kind: 'capture' });
    } else if (url) {
        movie.src = url;
        await movie.load();
        appendChat('Loaded URL: ' + url, 'system');
        // Publish URL for the guest to load
        publish(room.code, { type: 'movie_loaded', kind: 'url', url });
    } else {
        alert('Select file or public MP4 URL');
    }
});

// Enforce host-only control for UI buttons
playBtn.addEventListener('click', () => { if (isHost) movie.play(); else appendChat('Only the host can control playback.', 'system'); });
pauseBtn.addEventListener('click', () => { if (isHost) movie.pause(); else appendChat('Only the host can control playback.', 'system'); });

camToggle.addEventListener('change', async () => {
    camOverlay.style.display = camToggle.checked ? 'flex' : 'none';
    if (camToggle.checked) { await startCameraStream(); } else { stopCameraStream(); }
});

// Initial UI setup on load
window.onload = () => { updateUI(false); ensureRoomsTable(); };

window.addEventListener('beforeunload', () => { if (localStream) stopCameraStream(); });
</script>
</body>
</html>
